###1、分布式一致性
为解决分布式一致性问题的协议和算法：
1. 二阶段提交（2PC：Two Phase Commitment Protocol）
2. 三阶段提交（3PC：Three Phase Commitment Protocol）
3. Paxos算法

###2、2PC
* 1、协调者向所有参与者发送 Prepare 消息。
* 2、每个参与者要么超时（失败），要么返回可以执行（成功），或执行失败（失败）。
* 3、全部参与者返回 “成功” 后，协调者会发出commit的命令，否则callback。

存在的问题：
1. 同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
2. 单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）
3. 数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。
4. 二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

###3、3PC
三阶段
* 1、CanCommit
* 2、PreCommit
* 3、DoCommit
引入了超时机制。
在第一阶段和第二阶段中插入了一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。
https://www.cnblogs.com/AndyAo/p/8228099.html

###4、Paxos算法
角色：
Proposer：议案发起者。
Acceptor：决策者，可以批准议案。
Learn：最终决策的学习者。

Paxos算法要实现的目标：
* T1. 一次选举必须要选定一个议案（不能出现所有议案都被拒绝的情况）
* T2. 一次选举必须只选定一个议案（不能出现两个议案有不同的值，却都被选定的情况）

Paxos算法推导：
1. 一个Acceptor必须接受它收到的第一个议案
    如果只有一个Acceptor，一个Proposer。如果Acceptor拒绝了Proposer的议案，那么必然导致Paxos的目标T1无法达成。
2. 

###5、总结
相对于2PC，3PC主要解决的是单点故障问题，并减少阻塞。
因为一旦参与者无法及时收到来自协调者的信息之后，它就会默认执行commit。而不会一直持有事务资源并处于阻塞状态。
这种机机制也会导致数据一致性问题，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就导致了数据不一致。

无论2PC还是3PC丢无法彻底解决分布式的一致性问题，世上只有一种一致性算法，那就是Paxos算法。
