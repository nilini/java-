1、private修饰的方法可以通过反射访问，那么private的意义是什么
2、Java类初始化顺序
3、对方法区和永久区的理解以及它们之间的关系
4、一个java文件有3个类，编译后有几个class文件
5、局部变量使用前需要显式地赋值，否则编译通过不了，为什么这么设计
6、ReadWriteLock读写之间互斥吗
7、Semaphore拿到执行权的线程之间是否互斥
8、写一个你认为最好的单例模式
9、B树和B+树是解决什么样的问题的，怎样演化过来，之间区别
10、写一个生产者消费者模式
11、写一个死锁
12、cpu 100%怎样定位
13、String a = "ab"; String b = "a" + "b";  a == b 是否相等，为什么     
14、int a = 1; 是原子性操作吗
15、可以用for循环直接删除ArrayList的特定元素吗？可能会出现什么问题？怎样解决              
16、新的任务提交到线程池，线程池是怎样处理
17、AQS和CAS原理
18、synchronized底层实现原理
18、volatile作用，指令重排相关
20、AOP和IOC原理
21、Spring怎样解决循环依赖的问题
22、dispatchServlet怎样分发任务的
23、mysql给离散度低的字段建立索引会出现什么问题，具体说下原因
=====================================================================================================================
=====================================================================================================================
1、private修饰的方法可以通过反射访问，那么private的意义是什么？
java的private修饰符并不是为了绝对安全性设计的，更多是对用户常规使用java的一种约束；public..privare的区分，是为了
部暴露内部实现，属面向对象封装的理念。但特殊情况下，需要关注甚至修改内部实现。setAccessiable是一种hack。安全是一整套
体系，环环相扣，java有SecurityManager。

2、Java类初始化顺序
单类：静态变量（静态初始块） > 成员变量（非静态初始块）> 构造器
父类子类：父类静态变量（父类静态初始块）> 子类静态变量（子类静态初始块 ）> 父类成员变量（ 父类非静态初始块） > 父类构造器 > 子类成员变量（子类非静态初始块）> 子类构造器
静态变量和静态初始化快的初始化顺序和类中定义的顺序一致。
成员变量和非静态初始化块初始化顺序和类中定义的顺序一致。

3、对方法区和永久区的理解以及它们之间的关系
方法区是JVM规范中的一部分，并不是实际的实现。存储类信息、常量、静态变量、即时编译器编译后的代码等数据。
永久代是方法区的一种实现。HotSpot将GC分代收集至方法区。
jdk 8 把类的元数据放到了本地堆内存（native heap）中，这一块区域就叫做Metaspace即元空间。字符串常量移至Java Heap。
如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。