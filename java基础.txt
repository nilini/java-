1、private修饰的方法可以通过反射访问，那么private的意义是什么
2、Java类初始化顺序
3、对方法区和永久区的理解以及它们之间的关系
4、一个java文件有3个类，编译后有几个class文件
5、局部变量使用前需要显式地赋值，否则编译通过不了，为什么这么设计
6、ReadWriteLock读写之间互斥吗
7、Semaphore拿到执行权的线程之间是否互斥
8、写一个你认为最好的单例模式
9、B树和B+树是解决什么样的问题的，怎样演化过来，之间区别
10、写一个生产者消费者模式
11、写一个死锁
12、cpu 100%怎样定位
13、String a = "ab"; String b = "a" + "b";  a == b 是否相等，为什么     
14、int a = 1; 是原子性操作吗
15、可以用for循环直接删除ArrayList的特定元素吗？可能会出现什么问题？怎样解决              
16、新的任务提交到线程池，线程池是怎样处理
17、AQS和CAS原理
18、synchronized底层实现原理
18、volatile作用，指令重排相关
20、AOP和IOC原理
21、Spring怎样解决循环依赖的问题
22、dispatchServlet怎样分发任务的
23、mysql给离散度低的字段建立索引会出现什么问题，具体说下原因
24、Object类的主要方法？
=====================================================================================================================
=====================================================================================================================
1、private修饰的方法可以通过反射访问，那么private的意义是什么？
java的private修饰符并不是为了绝对安全性设计的，更多是对用户常规使用java的一种约束；public..privare的区分，是为了
部暴露内部实现，属面向对象封装的理念。但特殊情况下，需要关注甚至修改内部实现。setAccessiable是一种hack。安全是一整套
体系，环环相扣，java有SecurityManager。

2、Java类初始化顺序
单类：静态变量（静态初始块） > 成员变量（非静态初始块）> 构造器
父类子类：父类静态变量（父类静态初始块）> 子类静态变量（子类静态初始块 ）> 父类成员变量（ 父类非静态初始块） > 父类构造器 > 子类成员变量（子类非静态初始块）> 子类构造器
静态变量和静态初始化快的初始化顺序和类中定义的顺序一致。
成员变量和非静态初始化块初始化顺序和类中定义的顺序一致。

3、对方法区和永久区的理解以及它们之间的关系
方法区是JVM规范中的一部分，并不是实际的实现。存储类信息、常量、静态变量、即时编译器编译后的代码等数据。
永久代是方法区的一种实现。HotSpot将GC分代收集至方法区。
jdk 8 把类的元数据放到了本地堆内存（native heap）中，这一块区域就叫做Metaspace即元空间。字符串常量移至Java Heap。
如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。

4、一个java文件有3个类，编译后有几个class文件
几个类几个class文件，如果一个类有内部类，则该内部类的class文件命名为: [外部类名]$[内部类名].class

5、局部变量使用前需要显式地赋值，否则编译通过不了，为什么这么设计
局部变量必须先赋值后访问；成员变量则不必。
对于成员变量而言，其赋值和取值访问的先后顺序是具有不确定的，成员变量的赋值和访问方法的先后顺序是在运行时
发生的，在编译器来看确定不了，对于没有把握的事情，javac时不会去做的，这种事情交给运行时JVM就可以了。
对于局部变量而言，其赋值和取值访问顺序时可以确定的。

6、ReadWriteLock读写之间互斥吗

7、Semaphore拿到执行权的线程之间是否互斥
Semaphore可有多把锁，可允许多个线程同时拥有执行权，这些有执行权的线程如并发访问同一对象，会产生线程安全问题。

13、String a = "ab"; String b = "a" + "b";  a == b 是否相等，为什么     
相等，编译器会将"a"+"b"优化为"ab"。

一是String类是一个final类，不能产生一个String的子类；
二是在String类中提供的所有方法中，如果有String返回值就会创建一个String对象，不对原对象进行修改，这就保证了原对象不可改变。

new String("abc");创建的字符串对象不存储在字符串池。
new String("abc").intern();将字符串对象存储在字符串池，如果字符串池已经有了同样值的字符串，则返回引用。
String str = "abc";JVM去字符串池找相同值的字符串，如果有，则返回找到的字符串引用。否则创建一个新的字符串对象并存储在字符串池。

String是不可变类，线程安全。对String进行操作的时候，总是会创建新的字符串。
StringBuffer是可变类，线程安全。
StringBuilder是可变类，线程不安全。

使用“==”比较两个字符串，不仅比较字面量值，而且比较地址。
使用equals值比较值。

14、int a = 1; 是原子性操作吗
原子操作是指不会被线程调度机制打断的操作。
int a=1; // 是原子操作
a++; // 不是原子操作，先取出a，加1之后再写回去。

15、可以用for循环直接删除ArrayList的特定元素吗？可能会出现什么问题？怎样解决
不可以，list.remove(i)删除元素后会将其后的元素向前移动，有的元素会遍历不到。
可以倒序删除; 或者使用迭代器; 或者每次循环时重新获取size, 并且在删除元素之后i--。
迭代器在每次删除元素之后，会将迭代指示器指向刚刚删除的位置，所以不会漏掉元素。 

23、mysql给离散度低的字段建立索引会出现什么问题，具体说下原因

24、Object类的主要方法？
    (1) clone()
        复制引用，两个引用指向同样一个对象。
        克隆对象Object ob2 = ob1.clone();，两个引用指向两个对象。
        浅复制：只能复制对象，不能复制对象内部的引用。
        深复制：复制对象的全部，及其引用。
        覆盖Object中的clone方法，实现Clonable接口。
        @Override
        protected Object clone() throws CloneNotSupportedException {
            Body newBody = (Body) super.clone();
            newBody.head = (Head) head.clone();
            return newBody;
        }
        同时Head也要实现Clonanle，重写clone，执行super.clone()
    (2) finalize()
        一个对象被GC之前会调用finalize()，可以重写finalize()让即将被清理的对象起死回生（Person.person = this;）
        finalize()至多由GC执行一次，用户可以手动调用对象的finalize(),但并不影响GC对finalize的行为。
    (3) toString()
        public String toString() {
            return getClass().getName() + "@" + Integer.toHexString(hashCode());
        }
    (4) getClass()
        getClass()获取对象的类型类。
        .class获取类的类型类