静态代理和动态代理的区别？
1、静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，
    如果目标对象过多，则会产生很多代理类。
2、JDK动态代理需要目标对象实现业务接口，代理类只需要实现InvocationHandler接口。
    反射机制，比较消耗系统性能，但可以减少代理类的数量。
    利用反射机制生成一个实现代理接口的类，JDK通过ProxyGenerator.generateProxyClass()生成字节码，再进行类加载。
    因为JDK动态代理底层代码实现继承了Proxy类，Java是单继承，所以只能代理接口。
3、cglib（Code Generation Library）是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的拓展。
   cglib封装了asm，可以在运行期动态生成新的class，此class只存在与内存中。
   cglib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以该方类或方法不要声明为final。
4、JDK动态代理只能代理接口类。
   JDK动态代理不依赖其他包，Cglib需要导入ASM包。
5、JDK动态代理机制是委托机制，动态实现接口类，在动态生成的实现类里面委托为handler去调用原始实现类。
   Cglib则使用继承机制，被代理类和代理类是继承关系。
6、Spring AOP中代理选择
    1) 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP。
    2) 如果目标对象实现了接口，也是可以强制使用cglib实现AOP。
    3) 如果目标对象没有实现接口，则会使用cglib。
    通过@EnableAspectJAutoProxy(proxyTargetClass = true)
7、ASM是一个java字节码操控框架，它能被用来动态生成类或则增强既有类的功能。ASM可以直接产生二进制class文件，也可以在类被加载入Java虚拟机之前动态改变类行为。
8、Spring AOP用到了动态代理；
   Spring 事务管理用到了动态代理；
   MyBatis数据库连接池用到了动态代理；
   MyBatis创建Mapper用到了动态代理。

    