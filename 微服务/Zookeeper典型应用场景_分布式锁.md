###1、分布式锁
分布式锁是控制分布式系统之间同步访问共享资源的一种方式。

###2、排他锁
####2.1 定义锁
    Zookeeper中通过数据节点来表示一个锁，如/exclusive_lock/lock节点就可以被定义为一个锁。
####2.2 获取锁
    在需要获取排他锁时，所有的客户端都会视图通过调用create()接口，在/exclusive_lock节点下创建临时子节点/exclusive_lock/lock，最终只有一个客户端能够创建成功。
    所有没有获取到锁的客户端就需要到/exclusive_lock节点上注册一个子节点变更的Watcher监听。以便实时监听到lock节点的变更情况。
####2.3 释放锁
* 当前获取锁的客户端机器宕机后，那么Zookeeper上的这个临时节点就会被移除。
* 正常执行完业务逻辑，客户端就会主动将自己创建的临时节点删除。
移除了lock节点，Zookeeper就会通知多有在/exclusive_lock节点上注册了子节点变更Watcher监听的客户端。这些客户端在接收到通知后，再次重新发起分布式获取锁，即重复"获取锁"的过程。

###3、共享锁
####3.1 获取锁
所有客户端都会到/shared_lock这个节点下面创建一个临时顺序节点。
如果当前是读请求，那么就创建如/shared_lock/192.168.0.1-R-00000001的节点。
如果是写请求，那么就创建如/shared_lock/192.168.0.1-W-00000001的节点。

####3.2 判断读写顺序
共享锁：读读可以共享，读写必须互斥。
创建完节点后，获取/shared_lock节点下的所有子节点，并对该节点注册了子节点变更的Watcher监听。
* 读请求：
    不能有比自己小的写节点存在。
* 写请求：
    自己必须是序号最小的节点。
####3.3 释放锁
    同排他锁
####3.4 羊群效应
![20170607091428631](/assets/u=4193674793,1749981384&fm=173&app=25&f=JPEG.jpg)
针对如上图所示的情况进行分析

1. 192.168.0.1首先进行读操作，完成后将节点/shared_lock/192.168.0.1-R-00000001删除。

2. 余下4台机器均收到这个节点移除的通知，然后重新从/shared_lock节点上获取一份新的子节点列表。

3. 每台机器判断自己的读写顺序，其中192.168.0.2检测到自己序号最小，于是进行写操作，余下的机器则继续等待。

4. 继续…

可以看到，192.168.0.1客户端在移除自己的共享锁后，Zookeeper发送了子节点更变Watcher通知给所有机器，然而除了给192.168.0.2产生影响外，对其他机器没有任何作用。大量的Watcher通知和子节点列表获取两个操作会重复运行，这样会造成系能鞥影响和网络开销，更为严重的是，如果同一时间有多个节点对应的客户端完成事务或事务中断引起节点小时，Zookeeper服务器就会在短时间内向其他所有客户端发送大量的事件通知，这就是所谓的羊群效应。

可以有如下改动来避免羊群效应。

1. 客户端调用create接口常见类似于/shared_lock/[Hostname]-请求类型-序号的临时顺序节点。

2. 客户端调用getChildren接口获取所有已经创建的子节点列表（不注册任何Watcher）。

3. 如果无法获取共享锁，就调用exist接口来对比自己小的节点注册Watcher。对于读请求：向比自己序号小的最后一个写请求节点注册Watcher监听。对于写请求：向比自己序号小的最后一个节点注册Watcher监听。

4. 等待Watcher通知，继续进入步骤2。

此方案改动主要在于：每个锁竞争者，只需要关注/shared_lock节点下序号比自己小的那个节点是否存在即可。