一、方法内联
    程序顺序执行到某个方法时，会根据该方法的地址找到该方法然后执行，执行完该方法后再返回。跳转之前要保护现场，返回之后要恢复线程，这就需要时间和空间的开销。
    内联函数就是在编译期，编译器将程序中出现的位置用函数体直接替换，这样就不会出现函数跳转问题。类内部有个函数签名和函数地址的映射表，但替换太多会导致内嵌之后的代码长度大大增加。增加了jvm解释字节码的时间。
    java 中使用final修饰的方法会被JVM当做内联函数。除此之外，如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身。

二、逃逸分析
    基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸；当被外部线程访问，称为线程逃逸。
    例如：
    public static StringBuffer craeteStringBuffer(String s1, String s2) {
            StringBuffer sb = new StringBuffer();
            sb.append(s1);
            sb.append(s2);
            return sb;
        }
    StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。

    甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。

    上述代码如果想要StringBuffer sb不逃出方法，可以这样写：
    public static String createStringBuffer(String s1, String s2) {
            StringBuffer sb = new StringBuffer();
            sb.append(s1);
            sb.append(s2);
            return sb.toString();
        }
    不直接返回 StringBuffer，那么StringBuffer将不会逃逸出方法。
    如果能证明一个对象不会逃逸到方法或线程外，则可能为这个变量进行一些高效的优化。
    1、栈上分配
        java中的对象都是在对上分配，而垃圾回收机制会回收收堆中不再使用的对象，筛选可回收对象以及回收对象整理内存都需要消耗时间。
        如果能够通过逃逸分析确定某些对象不会逃逸处方法之外，那么就可以让这个对象在栈上分配内存，这样该对象所占用的内存空间就可以
        随栈帧出栈而销毁，减轻了垃圾回收的压力。
    2、标量替换
        java虚拟机中的原始数据类型（int、long等数据类型以及reference类型等）都不能再进一步分解，他们就可以称为标量。
        相对的，如果一个数据可以继续分解，那它称为聚合量，java中典型的聚合量是对象。
        如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候就可以不创建这个对象，
        而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化，可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。
    3、同步消除
        即锁消除。如果发现不可能被共享的对象，则可以消除这些对象的锁操作。提高性能。
        例如：方法内部的StringBuffer如果不被方法外的变量引用则可消除其上的锁。
可是目前还不能保证逃逸分析的性能收益必定高于它的消耗，所以这项技术还不是很成熟。