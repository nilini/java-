mysql读写分离
1、架构
    一主多从架构的应用场景：读写分离。
    1）客户端主动做负载均衡，把数据库的连接信息放在客户端的连接层。由客户端来选择后端数据库进行查询。
    2）mysql和客户端之间有一个中间代理层proxy，客户端只连接proxy，由proxy根据请求类型和上下文决定请求的分发路由。

2、目标
    读写分离主要是为了分摊主库的压力。
3、过期读
    “在从库上督导系统的一个过期状态” 的现象，称为 “过期读”。
    解决方案：
        1）强制走主库方案
            对于必须拿到最新结果的请求，强制将其发到主库上；
            对于可以读到旧数据的请求，才将其发到从库上。
        2）sleep方案
            发布内容成功后，先用发布的内容填充，等到用户主动刷新的时候再去执行sql。
        3）判断主备无延迟方案
            1）show slave status结果里的seconds_behind_master参数的值，可以用来衡量主备延迟时间的长短。
            2）对比位点确保主备无延迟。
                Master_Log_File和Read_Master_Log_Pos表示的是读到的主库的最新位点。
                Relay_Master_Log_File和Exec_Master_Log_Pos表示的是备库执行的最新位点。
            3）GTID集合
                Auto_Position=1 ，表示这对主备关系使用了GTID协议。
                Retrieved_Gtid_Set，是备库收到的所有日志的GTID集合。
                Executed_Gtid_Set，是备库所有已经执行完成的GTID集合。
        4）配合semi-sync方案
            一个事务的binlog在主备库之间的状态：
            1）主库执行完成，写入binlog，并反馈给客户端。
            2）binlog被从主库发送给备库，备库收到。
            3）在备库执行binlog完成。
            客户端收到确认，但从库还没收到binlog。这样会有延迟。
            解决方案：启动semi-sync
            1）事务提交的时候，主库把binlog发给从库。
            2）从库收到binlog以后，发回给主库一个ack，表示收到了。
            3）主库收到这个ack以后，才能给客户端返回 “事务完成” 的确认。
            如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。 
            semi-sync + 位点判断的方案，只对一主一备的场景是成立的。在一主多从场景，主库只要等到一个从库的ack，就开始给客户端返回确认，这时，在从库上执行查询请求，就有两种情况：
            1）如果查询时落在了这个相应了ack的从库上，是能够确保读到的最新数据。
            2）如果查询时落到了其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。
            总结：
            1）一主多从的时候，在某些从库执行查询请求会存在过期读的现象。
            2）在持续延迟的情况下，可能会出现过度等待的问题。
        5）等主库位点方案
            命令：select master_pos_wait(file, pos[, timeout]);
            这条命令的逻辑如下：
            1）在从库执行；
            2）参数file和pos指的是主库上的文件名和位置；
            3）timeout可选，设置为正整数N表示这个函数最多等待N秒。
            返回结果：
            1）正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。
            2）如果执行期间，备库同步线程发生异常，则返回NULL;
            3）如果等待超过N秒，就返回-1；
            4）如果刚开始执行的时候，就发现已经执行过这个位置，则返回0。
            整个逻辑流程：
            1）事务更新完成后，马上执行show master status得到当前主库执行到的File和position。
            2）选定一个从库执行查询语句；
            3）在从库上执行select master_pos_wait(File, position, 1);
            4）如果返回值是>=0的正整数，则在这个从库执行查询语句；
            5）否则，到主库执行查询语句。
        6）等GTID方案
            需要启用GTID模式。
            命令：select wait_for_executed_gtid_set(gtid_set, 1)
            这条命令的逻辑：
            1）等待，直到这个库执行的事务中包含出入的gtid_set，返回0；
            2）超时返回1。
            业务逻辑流程：
            1）事务完成更新后，从返回包直接获取这个事务的GTID，记为gtid1;
            2）选定一个从库执行查询语句；
            3）在从库上执行select wait_for_executed_gtid_set(gtid, 1);
            4）如果返回值是0，则在这个从库执行查询语句；
            5）否则，到主库执行查询语句。


