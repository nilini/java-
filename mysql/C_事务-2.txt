mysql事务与锁
1、隔离级别中的可重复读：事务T启动的时候会创建一个视图 read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动的时候看到的一样。
2、begin/start transaction命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。
   立即启动一个事务，可以使用start transaction with consistent snapshot。
3、两个视图：
   1）查询语句定义的虚拟表，create view
   2）InnoDB实现MVCC时用到的一致性读视图。用于支持RC(读提交)和RR(可重复读)隔离级别的实现。
4、在可重复读隔离级别下，事务在启动的时候就 “拍了个快照”。这个快照是基于整个库的。
5、transaction id：
      InnoDB里面每个事务有一个唯一的事务ID，叫做transaction id。按申请顺序严格递增。
6、row trx_id:
      每行数据都有多个版本。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID, 记为row trx_id。
      同时旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。
7、undo log:
      提供回滚和多个行版本控制（MVCC）。
      在数据修改的时候，不仅记录了redo，还记录了相对应的undo，事务失败或回滚的时候，可以借助该undo进行回滚。
      可以认为：delete一条数据时，undo log中会记录一条对应的insert记录。
8、InnoDB利用了 “所有数据都有多个版本” 的特性，实现了 “秒级创建快照” 的能力。
9、先读后写:  
    事务中更新数据都是先读后写的，读是当前读。
    读当前事务，写更新到最新事务版本。
10、可重复读：
    核心就是一致性读；事务更新数据的时候，只能用当前读（事务开始时的视图），如果当前的记录的行锁被其他事务占用的话，就需要进入等待锁。
11、读提交的逻辑和可重复读的逻辑类似，主要区别：
    1）可重复读下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图。
    2）读提交下，每一个语句执行前都会重新算出一个新的视图。